<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Node.js 4.0 (二) | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="GeneratorGenerator 函数有多种理解角度。从语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。
执行 Generator 函数会返回一个遍历器对象，也就是说， Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。
形式上， Generator 函数是一个普通函数">
<meta property="og:type" content="article">
<meta property="og:title" content="Node.js 4.0 (二)">
<meta property="og:url" content="http://yoursite.com/2015/11/30/Node.js4.0-2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="GeneratorGenerator 函数有多种理解角度。从语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。
执行 Generator 函数会返回一个遍历器对象，也就是说， Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。
形式上， Generator 函数是一个普通函数">
<meta property="og:image" content="http://yoursite.com/growth-img/promises.png">
<meta property="og:updated_time" content="2016-01-31T16:27:53.500Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Node.js 4.0 (二)">
<meta name="twitter:description" content="GeneratorGenerator 函数有多种理解角度。从语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。
执行 Generator 函数会返回一个遍历器对象，也就是说， Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。
形式上， Generator 函数是一个普通函数">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="img/poplar3.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Poplar</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/tags/学习笔记">学习笔记</a></li>
				        
							<li><a href="/tags/随笔">随笔</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/ipoplar/" title="github">github</a>
					        
								<a class="rss" target="_blank" href="/#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="/#" title="zhihu">zhihu</a>
					        
								<a class="mail" target="_blank" href="/ipoplar@foxmail.com" title="mail">mail</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/Modernizr/" style="font-size: 10px;">Modernizr</a> <a href="/tags/Node-js/" style="font-size: 16px;">Node.js</a> <a href="/tags/Redis/" style="font-size: 12px;">Redis</a> <a href="/tags/cheerio/" style="font-size: 10px;">cheerio</a> <a href="/tags/code/" style="font-size: 10px;">code</a> <a href="/tags/jQuery/" style="font-size: 12px;">jQuery</a> <a href="/tags/meta/" style="font-size: 10px;">meta</a> <a href="/tags/mongoDB/" style="font-size: 10px;">mongoDB</a> <a href="/tags/node-js/" style="font-size: 14px;">node.js</a> <a href="/tags/web/" style="font-size: 20px;">web</a> <a href="/tags/学习笔记/" style="font-size: 18px;">学习笔记</a> <a href="/tags/爬虫/" style="font-size: 10px;">爬虫</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">All is well O(∩_∩)O~</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Poplar</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="img/poplar3.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">Poplar</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/tags/学习笔记">学习笔记</a></li>
		        
					<li><a href="/tags/随笔">随笔</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/ipoplar/" title="github">github</a>
			        
						<a class="rss" target="_blank" href="/#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="/#" title="zhihu">zhihu</a>
			        
						<a class="mail" target="_blank" href="/ipoplar@foxmail.com" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-Node.js4.0-2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/30/Node.js4.0-2/" class="article-date">
  	<time datetime="2015-11-29T16:00:00.000Z" itemprop="datePublished">2015-11-30</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Node.js 4.0 (二)
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Node-js/">Node.js</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/web/">web</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/学习笔记/">学习笔记</a></li></ul>
	</div>

        
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/WEB/">WEB</a>
	</div>


        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Generator">Generator</h2><p>Generator 函数有多种理解角度。从语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。</p>
<p>执行 Generator 函数会返回一个遍历器对象，也就是说， Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</p>
<p>形式上， Generator 函数是一个普通函数，但是有两个特征。一是，function 命令与函数名之间有一个星号；二是，函数体内部使用 yield 语句，定义不同的内部状态（ yield 语句在英语里的意思就是“产出”）。</p>
<a id="more"></a>
<pre><code><span class="function"><span class="keyword">function</span>* <span class="title">helloWorldGenerator</span>(<span class="params"></span>) </span>{
  <span class="keyword">yield</span> <span class="string">'hello'</span>;
  <span class="keyword">yield</span> <span class="string">'world'</span>;
  <span class="keyword">return</span> <span class="string">'ending'</span>;
}
<span class="keyword">var</span> hw = helloWorldGenerator();
</code></pre><p>上面代码定义了一个 Generator 函数 helloWorldGenerator ，它内部有两个 yield 语句 “hello” 和 “world” ，即该函数有三个状态：hello，world 和 return 语句（结束执行）。</p>
<p>然后， Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，遍历器对象（Iterator Object）。</p>
<h3 id="next_方法">next 方法</h3><p>　　调用遍历器对象的 next 方法，使得指针移向下一个状态。也就是说，每次调用 next 方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个 yield 语句（或 return 语句）为止。换言之， Generator 函数是分段执行的，yield 语句是暂停执行的标记，而 next 方法可以恢复执行。</p>
<pre><code>hw.<span class="function"><span class="title">next</span><span class="params">()</span></span>
<span class="comment">// { value: 'hello', done: false }</span>
hw.<span class="function"><span class="title">next</span><span class="params">()</span></span>
<span class="comment">// { value: 'world', done: false }</span>
hw.<span class="function"><span class="title">next</span><span class="params">()</span></span>
<span class="comment">// { value: 'ending', done: true }</span>
hw.<span class="function"><span class="title">next</span><span class="params">()</span></span>
<span class="comment">// { value: undefined, done: true }</span>
</code></pre><p>上面代码一共调用了四次 next 方法。</p>
<p>　　第一次调用， Generator 函数开始执行，直到遇到第一个 yield 语句为止。next 方法返回一个对象，它的 value 属性就是当前 yield 语句的值 hello，done 属性的值 false，表示遍历还没有结束。</p>
<p>　　第二次调用，Generator 函数从上次 yield 语句停下的地方，一直执行到下一个 yield 语句。next 方法返回的对象的 value 属性就是当前 yield 语句的值 world，done 属性的值 false，表示遍历还没有结束。</p>
<p>　　第三次调用，Generator 函数从上次 yield 语句停下的地方，一直执行到 return 语句（如果没有 return 语句，就执行到函数结束）。next 方法返回的对象的 value 属性，就是紧跟在 return 语句后面的表达式的值（如果没有 return 语句，则 value 属性的值为 undefined ）， done 属性的值 true，表示遍历已经结束。</p>
<p>　　第四次调用，此时 Generator 函数已经运行完毕，next方法返回对象的 value 属性为 undefined，done 属性为 true 。以后再调用 next 方法，返回的都是这个值。</p>
<p>　　总结一下，调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的 next 方法，就会返回一个有着 value 和 done 两个属性的对象。 value 属性表示当前的内部状态的值，是 yield 语句后面那个表达式的值； done 属性是一个布尔值，表示是否遍历结束。</p>
<h3 id="yield*_语句">yield* 语句</h3><p>用来在一个 Generator 函数里面执行另一个 Generator 函数，我们需要用 yield* 语句。</p>
<p>如果 yield 命令后面跟的是一个遍历器对象，需要在 yield 命令后面加上星号，表明它返回的是一个遍历器对象。这被称为 yield* 语句。</p>
<pre><code><span class="function"><span class="keyword">function</span>* <span class="title">anotherGenerator</span>(<span class="params">i</span>) </span>{
  <span class="keyword">yield</span> i + <span class="number">1</span>;
  <span class="keyword">yield</span> i + <span class="number">2</span>;
  <span class="keyword">yield</span> i + <span class="number">3</span>;
}
<span class="function"><span class="keyword">function</span>* <span class="title">generator</span>(<span class="params">i</span>)</span>{
  <span class="keyword">yield</span> i;
  <span class="keyword">yield</span>* anotherGenerator(i);
  <span class="keyword">yield</span> i + <span class="number">10</span>;
}
<span class="keyword">var</span> gen = generator(<span class="number">10</span>);
<span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 10</span>
<span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 11</span>
<span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 12</span>
<span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 13</span>
<span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 20</span>
</code></pre><p>运行结果就是使用一个遍历器，遍历了多个 Generator 函数，有递归的效果。</p>
<h2 id="Promise">Promise</h2><p>所谓 Promise，就是一个对象，用来传递异步操作的消息。</p>
<p>Promise 对象有以下两个特点。</p>
<p>（1）对象的状态不受外界影响。Promise 对象代表一个异步操作，有三种状态：Pending （进行中）、Resolved （已完成，又称 ulfilled ）和 Rejected （已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p>
<p>（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise 对象的状态改变，只有两种可能：从 Pending 变为 Resolved 和从 Pending 变为 Rejected 。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对 Promise 对象添加回调函数，也会立即得到这个结果。这与事件 （Event） 完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p>
<h3 id="基本用法">基本用法</h3><p>ES6 规定，Promise 对象是一个构造函数，用来生成 Promise 实例。</p>
<p>下面代码创造了一个 Promise 实例。</p>
<pre><code><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>{
  <span class="comment">// ... some code</span>

  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>){
    resolve(value);
  } <span class="keyword">else</span> {
    reject(error);
  }
});
</code></pre><p>Promise 构造函数接受一个函数作为参数，该函数的两个参数分别是 resolve 和 reject 。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</p>
<p>resolve 函数的作用是，将 Promise 对象的状态从“未完成”变为“成功”（即从 Pending 变为 Resolved ），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去； reject 函数的作用是，将 Promise 对象的状态从“未完成”变为“失败”（即从 Pending 变为 Rejected ），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>
<p>Promise 实例生成以后，可以用 then 方法分别指定 Resolved 状态和 Reject 状态的回调函数。</p>
<pre><code><span class="transposed_variable">promise.</span><span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(value)</span> {</span>
  <span class="comment">// success</span>
}, <span class="function"><span class="keyword">function</span><span class="params">(value)</span> {</span>
  <span class="comment">// failure</span>
});
</code></pre><p>then 方法可以接受两个回调函数作为参数。第一个回调函数是 Promise 对象的状态变为 Resolved 时调用，第二个回调函数是 Promise 对象的状态变为 Reject 时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受 Promise 对象传出的值作为参数。</p>
<h3 id="Promise-prototype-then()_与_catch()">Promise.prototype.then() 与 catch()</h3><p>因为 Promise.prototype.then 和 Promise.prototype.catch 方法返回 promises , 所以它们可以被链式调用—一种被称为 composition 的操作.</p>
<p><img src="/growth-img/promises.png" alt=""></p>
<h3 id="Promise-prototype-then()">Promise.prototype.then()</h3><p>then() 方法返回一个 Promise。它有两个参数，分别为 Promise 在 success 和 failure 情况下的回调函数。</p>
<pre><code><span class="transposed_variable">p.</span><span class="keyword">then</span>(onFulfilled, onRejected);
<span class="transposed_variable">p.</span><span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(value)</span> {</span>
   <span class="comment">// 满足</span>
  }, <span class="function"><span class="keyword">function</span><span class="params">(reason)</span> {</span>
  <span class="comment">// 拒绝</span>
});
</code></pre><p>一个 Function , 当 Promise 为 fulfilled 时调用. 该函数有一个参数, 为肯定结果 value；为 rejected 时调用. 该函数有一个参数, 为否定原因 reason 。</p>
<p>因为 then 方法返回一个 Promise ，你可以轻易地链式调用 then 。</p>
<pre><code>var p2 = new Promise(<span class="function"><span class="keyword">function</span><span class="params">(resolve, reject)</span></span> {
  resolve(<span class="number">1</span>);
});

p2.<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(value)</span></span> {
  console.<span class="built_in">log</span>(<span class="keyword">value</span>); // <span class="number">1</span>
  <span class="keyword">return</span> <span class="keyword">value</span> + <span class="number">1</span>;
}).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(value)</span></span> {
  console.<span class="built_in">log</span>(<span class="keyword">value</span>); // <span class="number">2</span>
});
</code></pre><h3 id="Promise-prototype-catch()">Promise.prototype.catch()</h3><p>catch() 方法只处理 Promise 被拒绝的情况，并返回一个 Promise 。该方法的行为和调用 Promise.prototype.then(undefined, onRejected) 相同。</p>
<p>语法<br>    p.catch(onRejected);</p>
<pre><code>p.<span class="keyword">catch</span>(<span class="function"><span class="keyword">function</span><span class="params">(reason)</span> </span>{
   <span class="comment">// 拒绝</span>
});
</code></pre><p> onRejected 当 Promise 被拒绝时调用的 Function 。该函数调用时会传入一个参数：拒绝原因。</p>
<pre><code>示例:使用<span class="keyword">catch</span>方法
<span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>{
  resolve(<span class="string">"成功"</span>);
});

p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>{
  <span class="built_in">console</span>.log(value); <span class="comment">// "成功!"</span>
  <span class="keyword">throw</span> <span class="string">"哦，不!"</span>;
}).catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>{
  <span class="built_in">console</span>.log(e); <span class="comment">// "哦，不!"</span>
});
</code></pre><p>catch 方法主要作用于处理 promise 组合。</p>
<h3 id="Promise-all()">Promise.all()</h3><p>Promise.all 方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p>
<pre><code><span class="label">var</span> p = Promise.all([<span class="literal">p1</span>,<span class="literal">p2</span>,<span class="literal">p3</span>])<span class="comment">;</span>
</code></pre><p>　　上面代码中， Promise.all 方法接受一个数组作为参数， p1、p2、p3 都是 Promise 对象的实例，如果不是，就会先调用下面讲到的 Promise.resolve 方法，将参数转为 Promise 实例，再进一步处理。（ romise.all 方法的参数不一定是数组，但是必须具有 iterator 接口，且返回的每个成员都是 Promise 实例。）</p>
<p>p 的状态由 p1、p2、p3 决定，分成两种情况。</p>
<p>（1）只有 p1、p2、p3 的状态都变成 fulfilled ，p 的状态才会变成 fulfilled，此时 p1、p2、p3 的返回值组成一个数组，传递给 p 的回调函数。</p>
<p>（2）只要 p1、p2、p3 之中有一个被 rejected，p 的状态就变成 rejected，此时第一个被 reject 的实例的返回值，会传递给 p 的回调函数。</p>
<p>下面是一个具体的例子。</p>
<pre><code><span class="comment">// 生成一个Promise对象的数组</span>
<span class="keyword">var</span> promise = <span class="built_in">Promise</span>.resolve(<span class="number">3</span>);
<span class="built_in">Promise</span>.all([<span class="literal">true</span>, promise])
       .then(values =&gt; {
           <span class="built_in">console</span>.log(values); <span class="comment">// [true, 3]</span>
        });
</code></pre><h3 id="Promise-race()">Promise.race()</h3><p>race 函数返回一个 Promise ，这个 Promise 根据传入的 Promise 中的第一个确定状态–不管是接受还是拒绝–的状态而确定状态。</p>
<p>Promise.race 方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p>
<pre><code><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>{ 
    setTimeout(resolve, <span class="number">500</span>, <span class="string">"one"</span>); 
});
<span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>{ 
    setTimeout(resolve, <span class="number">100</span>, <span class="string">"two"</span>); 
});
<span class="built_in">Promise</span>.race([p1, p2]).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>{
  <span class="built_in">console</span>.log(value); <span class="comment">// "two"</span>
  <span class="comment">// Both resolve, but p2 is faster</span>
});
</code></pre><p>上面代码中，只要 p1、p2 之中有一个实例率先改变状态，p 的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给 p 的回调函数。</p>
<h3 id="Prommise-reject()">Prommise.reject()</h3><p>Promise.reject(reason) 方法也会返回一个新的 Promise 实例，该实例的状态为 rejected 。 Promise.reject 方法的参数 reason ，会被传递给实例的回调函数。</p>
<p>使用静态的 Promise.reject() 方法</p>
<pre><code><span class="built_in">Promise</span>.reject(<span class="string">"Testing static reject"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>{
  <span class="comment">// 未被调用</span>
}, <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>{
  <span class="built_in">console</span>.log(reason); <span class="comment">// "测试静态拒绝"</span>
});

<span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"fail"</span>)).then(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>{
  <span class="comment">// 未被调用</span>
}, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>{
  <span class="built_in">console</span>.log(error); <span class="comment">// 堆栈跟踪</span>
});
</code></pre><h3 id="Promise-resolve()">Promise.resolve()</h3><p>Promise.resolve(value) 方法返回一个以给定值 resolve 掉的 Promise 对象。但如果这个值是 thenable 的（就是说带有 then 方法），返回的 promise 会“追随”这个 thenable 的对象，接收它的最终状态（指 resolved/rejected/pendding/settled ）；否则这个被返回的 promise 对象会以这个值被 fulfilled 。</p>
<p>语法<br>    Promise.resolve(value);<br>    Promise.resolve(promise);<br>    Promise.resolve(thenable);<br>value 用来 resolve 待返回的 promise 对象的参数。既可以是一个 Promise 对象也可以是一个 thenable 。</p>
<p>静态方法 Promise.resolve 返回一个 Promise 对象，这个 Promise 对象是被 resolve 的。</p>
<p>示例<br>使用静态方法 Promise.resolve</p>
<pre><code><span class="built_in">Promise</span>.resolve(<span class="string">"Success"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>{
  <span class="built_in">console</span>.log(value); <span class="comment">// "Success"</span>
}, <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>{
  <span class="comment">// not called</span>
});
</code></pre><p>以一个数组进行 resolve</p>
<pre><code><span class="keyword">var</span> p = <span class="built_in">Promise</span>.resolve([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);
p.then(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>{
  <span class="built_in">console</span>.log(v[<span class="number">0</span>]); <span class="comment">// 1</span>
});
</code></pre><p>resolve 另一个 Promise 对象</p>
<pre><code><span class="keyword">var</span> original = <span class="built_in">Promise</span>.resolve(<span class="literal">true</span>);
<span class="keyword">var</span> cast = <span class="built_in">Promise</span>.resolve(original);
cast.then(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>{
  <span class="built_in">console</span>.log(v); <span class="comment">// true</span>
});
</code></pre><h2 id="Symbol">Symbol</h2><p>　　ES6 引入了一种新的原始数据类型 Symbol ，表示独一无二的值。它是JavaScript 语言的第七种数据类型，前六种是：Undefined、Null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。</p>
<p>　　Symbol 值通过 Symbol 函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p>
<pre><code><span class="keyword">let</span> s = <span class="built_in">Symbol</span>();
<span class="keyword">typeof</span> s
<span class="comment">// "symbol"</span>
</code></pre><p>　　注意， Symbol 函数前不能使用 new 命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。</p>
<p>Symbol 函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p>
<p>Symbol 函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的Symbol 函数的返回值是不相等的。</p>
<pre><code><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>(<span class="string">"foo"</span>);
<span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>(<span class="string">"foo"</span>);
<span class="built_in">console</span>.log(s1 === s2); <span class="comment">// false</span>
</code></pre><p>Symbol 值不能与其他类型的值进行运算，会报错。</p>
<p>但是，Symbol 值可以显式转为字符串。</p>
<h3 id="symbol_属性名">symbol 属性名</h3><p>　由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。</p>
<pre><code><span class="keyword">var</span> mySymbol = <span class="built_in">Symbol</span>();
<span class="comment">// 第一种写法</span>
<span class="keyword">var</span> a = {};
a[mySymbol] = <span class="string">'Hello!'</span>;
<span class="comment">// 第二种写法</span>
<span class="keyword">var</span> a = {
  [mySymbol]: <span class="string">'Hello!'</span>
};
<span class="comment">// 第三种写法</span>
<span class="keyword">var</span> a = {};
<span class="built_in">Object</span>.defineProperty(a, mySymbol, { value: <span class="string">'Hello!'</span> });
<span class="comment">// 以上写法都得到同样结果</span>
<span class="built_in">console</span>.log(a[mySymbol]); <span class="comment">// "Hello!"</span>
</code></pre><p>上面代码通过方括号结构和 Object.defineProperty ，将对象的属性名指定为一个 Symbol 值。</p>
<p>Symbol 值作为对象属性名时，不能用点运算符。</p>
<p>在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。</p>
<pre><code>let s = Symbol();
let obj = {
  [<span class="link_label">s</span>](<span class="link_url">arg</span>) { ... }
};
</code></pre><p>Symbol 类型还可以用于定义一组常量，保证这组常量的值都是不相等的。</p>
<p>Symbol 值作为属性名时，该属性还是公开属性，不是私有属性。</p>
<p><strong><em>属性名遍历</em></strong></p>
<p>Symbol 作为属性名，该属性不会出现在 for…in、for…of 循环中，也不会被 Object.keys()、Object.getOwnPropertyNames() 返回。但是，它也不是私有属性，有一个 Object.getOwnPropertySymbols 方法，可以获取指定对象的所有 Symbol 属性名。</p>
<p>Object.getOwnPropertySymbols 方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。</p>
<pre><code><span class="keyword">var</span> obj = {};
<span class="keyword">var</span> a = <span class="built_in">Symbol</span>(<span class="string">'a'</span>);
<span class="keyword">var</span> b = <span class="built_in">Symbol</span>(<span class="string">'b'</span>);

obj[a] = <span class="string">'Hello'</span>;
obj[b] = <span class="string">'World'</span>;
<span class="keyword">var</span> objectSymbols = <span class="built_in">Object</span>.getOwnPropertySymbols(obj);
<span class="built_in">console</span>.log(objectSymbols);
<span class="comment">// [Symbol(a), Symbol(b)]</span>
</code></pre><h3 id="Symbol-for()">Symbol.for()</h3><p>使用给定的 key 搜索现有符号，如果找到则返回符号。否则将得到一个新的使用给定的 key 在全局符号注册表中创建的符号。</p>
<p>　　有时，我们希望重新使用同一个 Symbol 值，Symbol.for 方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。</p>
<pre><code><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">'foo'</span>);
<span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">'foo'</span>);
console.log(s1 === s2); <span class="comment">// true</span>
</code></pre><p>上面代码中，s1 和 s2 都是 Symbol 值，但是它们都是同样参数的  Symbol.for 方法生成的，所以实际上是同一个值。</p>
<p>　　Symbol.for() 与 Symbol() 这两种写法，都会生成新的 Symbol 。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。 Symbol.for() 不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的 key 是否已经存在，如果不存在才会新建一个值。比如，如果你调用 Symbol.for(“cat”)  30 次，每次都会返回同一个 Symbol 值，但是调用 Symbol(“cat”)  30 次，会返回 30 个不同的 Symbol 值。</p>
<pre><code><span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">"bar"</span>) === <span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">"bar"</span>)
<span class="comment">// true</span>
<span class="built_in">Symbol</span>(<span class="string">"bar"</span>) === <span class="built_in">Symbol</span>(<span class="string">"bar"</span>)
<span class="comment">// false</span>
</code></pre><p>上面代码中，由于 Symbol() 写法没有登记机制，所以每次调用都会返回一个不同的值。</p>
<h3 id="Symbol-keyFor()">Symbol.keyFor()</h3><p>为给定符号从全局符号注册表中检索一个共享符号键。</p>
<p>Symbol.keyFor 方法返回一个已登记的 Symbol 类型值的 key。</p>
<pre><code><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">"foo"</span>);
<span class="built_in">Symbol</span>.keyFor(s1) <span class="comment">// "foo"</span>

<span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>(<span class="string">"foo"</span>);
<span class="built_in">Symbol</span>.keyFor(s2) <span class="comment">// undefined</span>
</code></pre><p>上面代码中，变量 s2 属于未登记的 Symbol 值，所以返回 undefined</p>
<h2 id="箭头函数">箭头函数</h2><p>箭头函数就是个是简写形式的函数表达式,并且它拥有词法作用域的 this 值.箭头函数总是匿名的.</p>
<p>ES6允许使用“箭头”（=&gt;）定义函数。</p>
<pre><code><span class="keyword">var</span> f = v =&gt; v;

<span class="comment">//等同于：</span>

<span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span><span class="params">(v)</span> </span>{
  <span class="keyword">return</span> v;
};
</code></pre><p>如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。</p>
<pre><code><span class="keyword">var</span> f = () =&gt; <span class="number">5</span>;
<span class="comment">// 等同于</span>
<span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> <span class="params">()</span></span>{ <span class="keyword">return</span> <span class="number">5</span> };

<span class="keyword">var</span> sum = (num1, num2) =&gt; num1 + num2;
<span class="comment">// 等同于</span>
<span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span><span class="params">(num1, num2)</span> </span>{
  <span class="keyword">return</span> num1 + num2;
};
</code></pre><p>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用 return 语句返回。</p>
<pre><code>var sum = <span class="function"><span class="params">(num1, num2)</span> =&gt;</span> { <span class="keyword">return</span> num1 + num2; }
</code></pre><p>由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号。</p>
<pre><code>var getTempItem = <span class="keyword">id</span> =&gt; ({ <span class="keyword">id</span>: <span class="keyword">id</span>, name: <span class="string">"Temp"</span> });
</code></pre><p>箭头函数的一个用处是简化回调函数。</p>
<pre><code><span class="comment">// 正常函数写法</span>
[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].<span class="built_in">map</span>(function (x) {
  <span class="keyword">return</span> x * x;
});

<span class="comment">// 箭头函数写法</span>
[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].<span class="built_in">map</span>(x =&gt; x * x);
</code></pre><p>另一个例子是</p>
<pre><code>// 正常函数写法
<span class="keyword">var</span> <span class="literal">result</span> = values.sort(function(a, b) {
  <span class="keyword">return</span> a - b;
});

// 箭头函数写法
<span class="keyword">var</span> <span class="literal">result</span> = values.sort((a, b) =&gt; a - b);
</code></pre><p>如果不用箭头函数，可能就要占用多行，而且还不如现在这样写醒目。</p>
<p><strong><em>使用注意点</em></strong></p>
<p>（1）函数体内的 this 对象，绑定定义时所在的对象，而不是使用时所在的对象。</p>
<p>（2）不可以当作构造函数，也就是说，不可以使用 new 命令，否则会抛出一个错误。</p>
<p>（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 Rest 参数代替。</p>
<p>（4）不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。</p>
<p>this 对象的指向是可变的，但是在箭头函数中，它是固定的。</p>
<pre><code>function Timer () {
  <span class="keyword">this</span>.seconds = <span class="number">0</span>
  setInterval(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.seconds++, <span class="number">1000</span>)
}
var timer = <span class="keyword">new</span> Timer()
setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(timer.seconds), <span class="number">3100</span>)
<span class="regexp">//</span> <span class="number">3</span>
</code></pre><p>上面代码中，Timer 函数内部的 setInterval- 调用了 _this.seconds- 属性，通过箭头函数将 _this 绑定在 Timer 的实例对象。否则，输出结果是 0 ，而不是 3 。</p>
<h2 id="模板字符串">模板字符串</h2><p>模板字符串允许嵌入表达式，并且支持多行字符串和字符串插补特性。</p>
<p>　　模板字符串使用反引号 (<code> </code>) 来代替普通字符串中的用双引号和单引号。模板字符串可以包含特定语法 (${expression}) 的占位符。占位符中的表达式和周围的文本会一起传递给一个默认函数，该函数负责将所有的部分连接起来，如果一个模板字符串由表达式开头，则该字符串被称为带标签的模板字符串，该表达式通常是一个函数，它会在模板字符串处理后被调用，在输出最终结果前，你都可以在通过该函数对模板字符串来进行操作处理。</p>
<p>语法<br>    <code>string text</code></p>
<pre><code>`<span class="keyword">string</span> <span class="keyword">text</span> <span class="built_in">line</span> <span class="number">1</span>
 <span class="keyword">string</span> <span class="keyword">text</span> <span class="built_in">line</span> <span class="number">2</span>`

`<span class="keyword">string</span> <span class="keyword">text</span> ${expression} <span class="keyword">string</span> <span class="keyword">text</span>`

tag `<span class="keyword">string</span> <span class="keyword">text</span> ${expression} <span class="keyword">string</span> <span class="keyword">text</span>`
</code></pre><p><strong><em>多行字符串</em></strong></p>
<p>在新行中插入的任何字符都是模板字符串中的一部分，使用普通字符串，你可以通过以下的方式获得多行字符串：</p>
<pre><code>console.<span class="built_in">log</span>(<span class="string">"string text line 1\n\
</span><span class="built_in">string</span> text <span class="built_in">line</span> <span class="number">2</span><span class="string">");
</span>// <span class="string">"string text line 1
</span>// <span class="built_in">string</span> text <span class="built_in">line</span> <span class="number">2</span>"
</code></pre><p>要获得同样效果的多行字符串，只需使用如下代码：</p>
<pre><code>console.<span class="built_in">log</span>(`<span class="built_in">string</span> text <span class="built_in">line</span> <span class="number">1</span>
<span class="built_in">string</span> text <span class="built_in">line</span> <span class="number">2</span>`);
// <span class="string">"string text line 1
</span>// <span class="built_in">string</span> text <span class="built_in">line</span> <span class="number">2</span>"
</code></pre><p><strong><em>表达式插补</em></strong><br>在普通字符串中嵌入表达式，必须使用如下语法：</p>
<pre><code>var a = <span class="number">5</span>;
var b = <span class="number">10</span>;
console.<span class="built_in">log</span>(<span class="string">"Fifteen is "</span> + (a + b) + <span class="string">" and\nnot "</span> + (<span class="number">2</span> * a + b) + <span class="string">"."</span>);
<span class="comment">// "Fifteen is 15 and</span>
<span class="comment">// not 20."</span>
</code></pre><p>现在通过模板字符串，我们可以使用一种更优雅的方式来表示：</p>
<pre><code><span class="keyword">var</span> a = <span class="number">5</span>;
<span class="keyword">var</span> b = <span class="number">10</span>;
<span class="built_in">console</span>.log(<span class="string">`Fifteen is <span class="subst">${a + b}</span> and\nnot <span class="subst">${2 * a + b}</span>.`</span>);
<span class="comment">// "Fifteen is 15 and</span>
<span class="comment">// not 20."</span>
</code></pre><p><strong><em>带标签的模板字符串 </em></strong></p>
<p>模板字符串的一种更高级的形式称为带标签的模板字符串。它允许您通过标签函数修改模板字符串的输出。标签函数的第一个参数是一个包含了字符串字面值的数组（在本例中分别为“Hello”和“world”）；第二个参数，在第一个参数后的每一个参数，都是已经被处理好的替换表达式（在这里分别为“15”和“50”）。 最后，标签函数返回处理好的字符串。在后面的示例中，标签函数的名称可以为任意的合法标示符。</p>
<pre><code><span class="keyword">var</span> a = <span class="number">5</span>;
<span class="keyword">var</span> b = <span class="number">10</span>;

<span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">strings</span>) </span>{
  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);    <span class="comment">// { '0': [ 'Hello ', ' world ', '' ], '1': 15, '2': 50 }</span>
  <span class="built_in">console</span>.log(strings[<span class="number">0</span>]);   <span class="comment">// "Hello "</span>
  <span class="built_in">console</span>.log(strings[<span class="number">1</span>]);   <span class="comment">// " world "</span>
  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">1</span>]);  <span class="comment">// 15</span>
  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">2</span>]);  <span class="comment">// 50</span>

  <span class="keyword">return</span> <span class="string">"Hubwiz!"</span>;
}

<span class="built_in">console</span>.log(tag<span class="string">`Hello <span class="subst">${ a + b }</span> world <span class="subst">${ a * b}</span>`</span>);
<span class="comment">// "Hubwiz!"</span>
</code></pre><p>我们打印出arguments可以看到 处理的参数为</p>
<pre><code>{ <span class="string">'0'</span>: [ <span class="string">'Hello '</span>, <span class="string">' world '</span>, <span class="string">''</span> ], <span class="string">'1'</span>: <span class="number">15</span>, <span class="string">'2'</span>: <span class="number">50</span> }
</code></pre><p>我们已有的Hello和world参数放到一个数组中，后续处理的参数依次生成。</p>
<p><strong><em> 原始字符串</em></strong></p>
<p>在标签函数的第一个参数中，存在一个特殊的属性 raw ，我们可以通过它来访问模板字符串的原始字符串。</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">tag</span><span class="params">(strings, values)</span> {</span>
  console.<span class="built_in">log</span>(strings.raw[<span class="number">0</span>]); 
  // <span class="string">"string text line 1 \\n string text line 2"</span>
}

<span class="keyword">tag</span>`<span class="built_in">string</span> text <span class="built_in">line</span> <span class="number">1</span> \<span class="keyword">n</span> <span class="built_in">string</span> text <span class="built_in">line</span> <span class="number">2</span>`;
</code></pre><p>另外，使用 String.raw()  方法创建原始字符串和使用默认模板函数和字符串连接创建是一样的。</p>
<pre><code><span class="built_in">String</span>.raw<span class="string">`Hi\n<span class="subst">${2+3}</span>!`</span>;
<span class="comment">// "Hi\\n5!"</span>
</code></pre><p><em>安全性</em><br>由于模板字符串能够访问变量和函数，因此不能由不受信任的用户来构造。</p>
<pre><code><span class="pi">"use strict"</span>
<span class="keyword">let</span> a = <span class="number">10</span>;
<span class="built_in">console</span>.warn(<span class="string">`<span class="subst">${a+=20}</span>`</span>); <span class="comment">// "30"</span>
<span class="built_in">console</span>.warn(a); <span class="comment">// 30</span>
</code></pre><h2 id="字符串扩展">字符串扩展</h2><h3 id="字符的_Unicode_表示法">字符的 Unicode 表示法</h3><p>JavaScript 允许采用 \uxxxx 形式表示一个字符，其中 “xxxx” 表示字符的码点。</p>
<pre><code><span class="string">"\u0061"</span>   <span class="comment">// "a"</span>
</code></pre><p>但是，这种表示法只限于 \u0000——\uFFFF 之间的字符。超出这个范围的字符，必须用两个双字节的形式表达。</p>
<pre><code><span class="string">"\uD842\uDFB7"</span>  <span class="comment">// "𠮷"</span>
<span class="string">"\u20BB7"</span>  <span class="comment">// " 7"</span>
</code></pre><p>　　上面代码表示，如果直接在 “\u” 后面跟上超过 0xFFFF 的数值（比如 \u20BB7 ）， JavaScript 会理解成 “\u20BB+7” 。由于 \u20BB 是一个不可打印字符，所以只会显示一个空格，后面跟着一个 7 。</p>
<p>ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。</p>
<pre><code><span class="string">"\u{20BB7}"</span>
<span class="comment">// "𠮷"</span>
<span class="string">"\u{41}\u{42}\u{43}"</span>
<span class="comment">// "ABC"</span>
<span class="keyword">let</span> hello = <span class="number">123</span>;
hell\u{<span class="number">6</span>F} <span class="comment">// 123</span>
<span class="string">'\u{1F680}'</span> === <span class="string">'\uD83D\uDE80'</span>
<span class="comment">// true</span>
</code></pre><p>上面代码中，最后一个例子表明，大括号表示法与四字节的 UTF-16 编码是等价的。</p>
<p>有了这种表示法之后， JavaScript 共有 6 种方法可以表示一个字符。</p>
<pre><code><span class="string">'\z'</span> === <span class="string">'z'</span>  <span class="comment">// true</span>
<span class="string">'\172'</span> === <span class="string">'z'</span> <span class="comment">// true</span>
<span class="string">'\x7A'</span> === <span class="string">'z'</span> <span class="comment">// true</span>
<span class="string">'\u007A'</span> === <span class="string">'z'</span> <span class="comment">// true</span>
<span class="string">'\u{7A}'</span> === <span class="string">'z'</span> <span class="comment">// true</span>
</code></pre><h3 id="codePointAt()_字节">codePointAt() 字节</h3><p>codePointAt 方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。</p>
<pre><code>var s = <span class="string">"𠮷a"</span>;

s.codePointAt(<span class="number">0</span>) <span class="comment">// 134071</span>
s.codePointAt(<span class="number">1</span>) <span class="comment">// 57271</span>

s.charCodeAt(<span class="number">2</span>) <span class="comment">// 97</span>
</code></pre><p>　　codePointAt 方法的参数，是字符在字符串中的位置（从 0 开始）。上面代码中， JavaScript 将 “𠮷a” 视为三个字符， codePointAt 方法在第一个字符上，正确地识别了 “𠮷”，返回了它的十进制码点 134071 （即十六进制的 20BB7 ）。在第二个字符（即 “𠮷” 的后两个字节）和第三个字符 “a” 上， codePointAt 方法的结果与 charCodeAt 方法相同。</p>
<p>　　总之， codePointAt 方法会正确返回四字节的 UTF-16 字符的码点。对于那些两个字节储存的常规字符，它的返回结果与 charCodeAt 方法相同。</p>
<p>codePointAt 方法是测试一个字符由两个字节还是由四个字节组成的最简单方法。</p>
<pre><code><span class="keyword">function</span> <span class="keyword">is</span><span class="number">32</span>Bit(c) {
  <span class="keyword">return</span> c.codePointAt(<span class="number">0</span>) &gt; <span class="number">0</span>xFFFF;
}
<span class="keyword">is</span><span class="number">32</span>Bit(<span class="string">"𠮷"</span>) <span class="comment">// true</span>
<span class="keyword">is</span><span class="number">32</span>Bit(<span class="string">"a"</span>) <span class="comment">// false</span>
</code></pre><h3 id="String-fromCodePoint()">String.fromCodePoint()</h3><p>　ES5 提供 String.fromCharCode 方法，用于从码点返回对应字符，但是这个方法不能识别辅助平面的字符（编号大于 0xFFFF ）。</p>
<pre><code>String.<span class="function"><span class="title">fromCharCode</span><span class="params">(<span class="number">0</span>x20BB7)</span></span>
<span class="comment">// "ஷ"</span>
</code></pre><p>上面代码中， String.fromCharCode 不能识别大于 0xFFFF 的码点，所以 0x20BB7 就发生了溢出，最高位 2 被舍弃了，最后返回码点 U+0BB7 对应的字符，而不是码点 U+20BB7 对应的字符。</p>
<p>　　ES6 提供了 String.fromCodePoint 方法，可以识别 0xFFFF 的字符，弥补了 String.fromCharCode 方法的不足。在作用上，正好与 codePointAt 方法相反。</p>
<pre><code>String.<span class="function"><span class="title">fromCodePoint</span><span class="params">(<span class="number">0</span>x20BB7)</span></span>
<span class="comment">// "𠮷"</span>
</code></pre><p>注意，fromCodePoint 方法定义在 String 对象上，而 codePointAt 方法定义在字符串的实例对象上。</p>
<h3 id="includes(),_startsWidth(),_endsWidth()">includes(), startsWidth(), endsWidth()</h3><p>传统上，JavaScript 只有 indexOf 方法，可以用来确定一个字符串是否包含在另一个字符串中。</p>
<p>ES6又提供了三种新方法。</p>
<p>includes()：返回布尔值，表示是否找到了参数字符串。</p>
<p>startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。</p>
<p>endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。</p>
<pre><code>var s = <span class="string">'Hello world!'</span>;

s.<span class="keyword">startsWith</span>(<span class="string">'Hello'</span>) <span class="comment">// true</span>
s.<span class="keyword">endsWith</span>(<span class="string">'!'</span>) <span class="comment">// true</span>
s.includes(<span class="string">'o'</span>) <span class="comment">// true</span>
</code></pre><p>这三个方法都支持第二个参数，表示开始搜索的位置。</p>
<pre><code>var s = <span class="string">'Hello world!'</span>;

s.<span class="keyword">startsWith</span>(<span class="string">'world'</span>, <span class="number">6</span>) <span class="comment">// true</span>
s.<span class="keyword">endsWith</span>(<span class="string">'Hello'</span>, <span class="number">5</span>) <span class="comment">// true</span>
s.includes(<span class="string">'Hello'</span>, <span class="number">6</span>) <span class="comment">// false</span>
</code></pre><p>上面代码表示，使用第二个参数 n 时， endsWith 的行为与其他两个方法有所不同。它针对前 n 个字符，而其他两个方法针对从第 n 个位置直到字符串结束。</p>
<h3 id="repeat()_重复次数">repeat() 重复次数</h3><p>repeat 方法返回一个新字符串，表示将原字符串重复 n 次。</p>
<pre><code><span class="string">'x'</span>.<span class="function"><span class="title">repeat</span><span class="params">(<span class="number">3</span>)</span></span> <span class="comment">// "<span class="label">xxx"</span></span>
<span class="string">'hello'</span>.<span class="function"><span class="title">repeat</span><span class="params">(<span class="number">2</span>)</span></span> <span class="comment">// "hellohello"</span>
<span class="string">'na'</span>.<span class="function"><span class="title">repeat</span><span class="params">(<span class="number">0</span>)</span></span> <span class="comment">// ""</span>
</code></pre><p>参数如果是小数，会被取整。</p>
<pre><code><span class="string">'na'</span>.<span class="function"><span class="title">repeat</span><span class="params">(<span class="number">2.9</span>)</span></span> <span class="comment">// "nana"</span>
</code></pre><p>如果 repeat 的参数是负数或者 Infinity ，会报错。</p>
<pre><code><span class="string">'na'</span>.<span class="function"><span class="title">repeat</span><span class="params">(Infinity)</span></span>
<span class="comment">// RangeError</span>
<span class="string">'na'</span>.<span class="function"><span class="title">repeat</span><span class="params">(-<span class="number">1</span>)</span></span>
<span class="comment">// RangeError</span>
</code></pre><p>但是，如果参数是 0 到 -1 之间的小数，则等同于 0 ，这是因为会先进行取整运算。0 到 -1 之间的小数，取整以后等于 -0 ， repeat 视同为 0 。</p>
<pre><code><span class="string">'na'</span>.<span class="function"><span class="title">repeat</span><span class="params">(-<span class="number">0.9</span>)</span></span> <span class="comment">// ""</span>
</code></pre><p>参数 NaN 等同于 0 。</p>
<pre><code><span class="string">'na'</span>.<span class="function"><span class="title">repeat</span><span class="params">(NaN)</span></span> <span class="comment">// ""</span>
</code></pre><p>如果 repeat 的参数是字符串，则会先转换成数字。</p>
<pre><code><span class="string">'na'</span>.<span class="function"><span class="title">repeat</span><span class="params">(<span class="string">'na'</span>)</span></span> <span class="comment">// ""</span>
<span class="string">'na'</span>.<span class="function"><span class="title">repeat</span><span class="params">(<span class="string">'3'</span>)</span></span> <span class="comment">// "nanana"</span>
</code></pre>
      
    </div>    

    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2015/11/30/Node.js-session应用/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          Node.js-session 应用
        
      </div>
    </a>
  
  
    <a href="/2015/11/27/Node.js4.0/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Node.js 4.0 (一)</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到：</span>
		<a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
		<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>



<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="Node.js4.0-2" data-title="Node.js 4.0 (二)" data-url="http://yoursite.com/2015/11/30/Node.js4.0-2/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 Poplar
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>